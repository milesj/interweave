/* eslint-disable @typescript-eslint/no-explicit-any */

import React from 'react';

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace NodeJS {
    interface Global {
      INTERWEAVE_SSR_POLYFILL: () => Document | undefined;
    }
  }
}

export type Node = NonNullable<React.ReactNode>;

export type AttributeValue = string | number | boolean | object;

export interface Attributes {
  [attr: string]: AttributeValue;
}

export interface ElementProps {
  attributes?: Attributes;
  children?: React.ReactNode;
  selfClose?: boolean;
  tagName: string;
}

// CALLBACKS

export type OnAfterParse<Props> = (content: Node, props: Props) => Node;

export type OnBeforeParse<Props> = (content: string, props: Props) => string;

export type OnMatch<Match, Props, Options = {}> = (
  result: MatchResult,
  props: Props,
  options: Partial<Options>,
) => Match | null;

export interface CommonInternals<Props, Options = {}> {
  onAfterParse?: OnAfterParse<Props>;
  onBeforeParse?: OnBeforeParse<Props>;
  options: Partial<Options>;
}

// MATCHERS

export interface MatchResult {
  index: number;
  length: number;
  match: string;
  matches: string[];
  valid: boolean;
  value: string;
  void: boolean;
}

export type MatchHandler<Match, Props> = (
  value: string,
  props: Props,
) => (MatchResult & { params: Match }) | null;

export interface MatcherOptions<Match, Props, Options = {}> {
  greedy?: boolean;
  tagName: TagName;
  void?: boolean;
  options?: Options;
  onAfterParse?: OnAfterParse<Props>;
  onBeforeParse?: OnBeforeParse<Props>;
  onMatch: OnMatch<Match, Props, Options>;
}

export type MatcherFactory<Match, Props> = (
  match: Match,
  props: Props,
  content: Node,
) => React.ReactElement;

export interface Matcher<Match, Props, Options = {}> extends CommonInternals<Props, Options> {
  extend: (
    factory?: MatcherFactory<Match, Props> | null,
    options?: Partial<MatcherOptions<Match, Props, Options>>,
  ) => Matcher<Match, Props, Options>;
  factory: MatcherFactory<Match, Props>;
  greedy: boolean;
  match: MatchHandler<Match, Props>;
  tagName: TagName;
}

// TRANSFORMERS

export type InferElement<K> = K extends '*'
  ? HTMLElement
  : K extends keyof HTMLElementTagNameMap
  ? HTMLElementTagNameMap[K]
  : HTMLElement;

export type TransformerFactory<Element, Props> = (
  element: Element,
  props: Props,
  content: Node,
) => void | undefined | null | Element | React.ReactElement;

export interface TransformerOptions<Props, Options = {}> {
  tagName?: TagName;
  onAfterParse?: OnAfterParse<Props>;
  onBeforeParse?: OnBeforeParse<Props>;
  options?: Options;
}

export interface Transformer<Element, Props, Options = {}> extends CommonInternals<Props, Options> {
  extend: (
    factory?: TransformerFactory<Element, Props> | null,
    options?: Partial<TransformerOptions<Props, Options>>,
  ) => Transformer<Element, Props, Options>;
  factory: TransformerFactory<Element, Props>;
  tagName: WildTagName;
}

// PARSER

export interface ParserProps {
  /** Allow all non-banned HTML attributes. */
  allowAttributes?: boolean;
  /** Allow all non-banned and non-blocked HTML elements. */
  allowElements?: boolean;
  /** List of HTML tag names to allow and render. Defaults to the `ALLOWED_TAG_LIST` constant. */
  allow?: TagName[];
  /** List of HTML tag names to disallow and not render. Overrides allow list. */
  block?: TagName[];
  /** Disable the conversion of new lines to `<br />` elements. */
  disableLineBreaks?: boolean;
  /** Escape all HTML before parsing. */
  escapeHtml?: boolean;
  /** Strip all HTML while rendering. */
  noHtml?: boolean;
  /** Strip all HTML, except HTML generated by matchers or transformers, while rendering. */
  noHtmlExceptInternals?: boolean;
  /** The element to parse content in. Applies browser semantic rules. */
  tagName: TagName;
}

export interface MatchedElements {
  [token: string]: {
    element: React.ReactElement;
    key: number;
  };
}

// ELEMENTS

export type TagName = keyof React.ReactHTML | 'rb' | 'rtc';

export type WildTagName = TagName | '*';

export interface TagConfig {
  // Only children
  children: TagName[];
  // Children content type
  content: number;
  // Invalid children
  invalid: TagName[];
  // Only parent
  parent: TagName[];
  // Can render self as a child
  self: boolean;
  // HTML tag name
  tagName: TagName;
  // Self content type
  type: number;
  // Self-closing tag
  void: boolean;
}

export interface TagConfigMap {
  [tagName: string]: Partial<TagConfig>;
}

// INTERWEAVE

export interface MarkupProps extends ParserProps {
  /** HTML attributes to pass to the wrapping element. */
  attributes?: Attributes;
  /** Content that may contain HTML to safely render. */
  content?: string | null;
  /** Content to render when the `content` prop is empty. */
  emptyContent?: React.ReactNode;
  /** @ignore Pre-parsed content to render. */
  parsedContent?: React.ReactNode;
  /** Don't wrap the content in a new element specified by `tagName`. */
  noWrap?: boolean;
}

export interface InterweaveProps extends MarkupProps {
  /** List of transformers to apply to elements. */
  transformers?: Transformer<HTMLElement, {}>[];
  /** List of matchers to apply to the content. */
  matchers?: Matcher<{}, {}, {}>[];
  /** Callback fired after parsing ends. Must return an array of React nodes. */
  onAfterParse?: OnAfterParse<{}> | null;
  /** Callback fired beore parsing begins. Must return a string. */
  onBeforeParse?: OnBeforeParse<{}> | null;
}
